# Plugin Development Examples

Examples of creating and using Orchestra plugins.

## Basic Plugin

### 1. Custom Code Generator

```bash
orchestra plugin create --name custom-generator
```

Edit `.orchestra/plugins/custom-generator/index.js`:

```javascript
/**
 * Custom Code Generator Plugin
 * Generates code following team conventions
 */

export async function beforeExecute(context) {
  console.log('[Custom Generator] Preparing code generation...');

  // Add custom headers to all generated files
  context.metadata.customHeaders = [
    '// Copyright 2024 My Company',
    '// Author: ' + process.env.USER || 'Orchestra',
    '// Generated: ' + new Date().toISOString(),
  ];

  return { success: true };
}

export async function afterExecute(context) {
  console.log('[Custom Generator] Code generation complete');

  // Log generated files
  const files = context.metadata.filesCreated || [];
  console.log('Generated files:', files);

  return { success: true };
}
```

### 2. Notification Plugin

`orchestra.json`:

```json
{
  "name": "slack-notifier",
  "version": "1.0.0",
  "description": "Send notifications to Slack on Orchestra events",
  "main": "index.js",
  "hooks": {
    "on-complete": "onComplete",
    "on-error": "onError"
  }
}
```

`index.js`:

```javascript
export async function onComplete(context) {
  const webhookUrl = process.env.SLACK_WEBHOOK_URL;
  if (!webhookUrl) return { success: true };

  const message = `✅ Orchestra task completed: ${context.task}`;

  await fetch(webhookUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text: message }),
  });

  return { success: true };
}

export async function onError(context) {
  const webhookUrl = process.env.SLACK_WEBHOOK_URL;
  if (!webhookUrl) return { success: true };

  const message = `❌ Orchestra task failed: ${context.task}`;

  await fetch(webhookUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text: message }),
  });

  return { success: true };
}
```

### 3. Custom Linter Plugin

`index.js`:

```javascript
export async function afterExecute(context) {
  const { execSync } = require('child_process');

  try {
    // Run custom linter after code generation
    const result = execSync('npm run lint:strict', { encoding: 'utf-8' });

    console.log('[Custom Linter] Linting passed');
    return { success: true };
  } catch (error) {
    console.log('[Custom Linter] Linting failed:', error.stdout || error.message);

    // Optionally fail the task
    // return { success: false, stopPropagation: true };

    return { success: true };
  }
}
```

### 4. Documentation Generator Plugin

`index.js`:

```javascript
export async function afterExecute(context) {
  const { writeFileSync, mkdirSync } = require('fs');
  const path = require('path');

  const filesCreated = context.metadata.filesCreated || [];

  for (const file of filesCreated) {
    if (file.endsWith('.ts') || file.endsWith('.js')) {
      const docFile = file.replace(/\.(ts|js)$/, '.md');

      const content = `# ${path.basename(file, path.extname(file))}

Generated by Orchestra on ${new Date().toISOString()}

## Usage

\`\`\`typescript
// TODO: Add usage examples
\`\`\`
`;

      const dir = path.dirname(docFile);
      mkdirSync(dir, { recursive: true });
      writeFileSync(docFile, content);

      console.log(`[Doc Generator] Created ${docFile}`);
    }
  }

  return { success: true };
}
```

### 5. Code Review Checklist Plugin

`index.js`:

```javascript
const CHECKLIST = [
  'Has error handling',
  'Has input validation',
  'Has unit tests',
  'Follows naming conventions',
  'Has JSDoc comments',
  'No hardcoded secrets',
  'Uses environment variables',
];

export async function afterAudit(context) {
  const { readFileSync } = require('fs');

  const filesModified = context.metadata.filesModified || [];

  for (const file of filesModified) {
    console.log(`\n[Review Checklist] ${file}:`);

    const content = readFileSync(file, 'utf-8');

    for (const item of CHECKLIST) {
      // Simple checks (in real plugin, use AST analysis)
      const passed = checkContent(content, item);
      console.log(`  ${passed ? '✓' : '✗'} ${item}`);
    }
  }

  return { success: true };
}

function checkContent(content, item) {
  switch (item) {
    case 'Has error handling':
      return content.includes('try') && content.includes('catch');
    case 'Has input validation':
      return content.includes('validation') || content.includes('validate');
    case 'Has unit tests':
      return content.includes('.test.') || content.includes('.spec.');
    case 'Uses environment variables':
      return content.includes('process.env');
    default:
      return true;
  }
}
```

## Plugin Development Workflow

### 1. Create Plugin Scaffold

```bash
orchestra plugin create --name my-awesome-plugin
```

### 2. Edit Plugin Files

```bash
cd .orchestra/plugins/my-awesome-plugin

# Edit the manifest
vim orchestra.json

# Edit the code
vim index.js
```

### 3. Test Plugin Locally

```bash
# Load the plugin
orchestra plugin load --path .orchestra/plugins/my-awesome-plugin

# Enable it
orchestra plugin enable --name my-awesome-plugin

# Check status
orchestra plugin list

# Test it
orchestra start "Test task"
```

### 4. Debug Plugin

Add logging to your plugin:

```javascript
export async function beforeExecute(context) {
  console.log('[My Plugin] Context:', JSON.stringify(context, null, 2));

  // Your logic here

  return { success: true };
}
```

### 5. Publish Plugin

Create a proper npm package:

```bash
cd .orchestra/plugins/my-awesome-plugin

# Initialize npm
npm init -y

# Add metadata to package.json
cat > package.json << EOF
{
  "name": "orchestra-plugin-my-awesome-plugin",
  "version": "1.0.0",
  "description": "My awesome Orchestra plugin",
  "main": "index.js",
  "keywords": ["orchestra", "plugin"],
  "license": "MIT"
}
EOF

# Publish
npm publish
```

## Advanced Examples

### Plugin with Configuration

`orchestra.json`:

```json
{
  "name": "configurable-plugin",
  "version": "1.0.0",
  "description": "Plugin with custom configuration",
  "main": "index.js",
  "config": {
    "maxFileLines": 500,
    "enforceStyle": true,
    "customRules": ["no-console", "prefer-const"]
  },
  "hooks": {
    "before-execute": "beforeExecute"
  }
}
```

`index.js`:

```javascript
export async function init() {
  console.log('[Configurable Plugin] Initialized with config:', this.config);
}

export async function beforeExecute(context) {
  const config = context.manifest.config;

  console.log('Max file lines:', config.maxFileLines);
  console.log('Enforce style:', config.enforceStyle);
  console.log('Custom rules:', config.customRules);

  return { success: true };
}
```

### Plugin with Dependencies

`orchestra.json`:

```json
{
  "name": "plugin-with-dependencies",
  "version": "1.0.0",
  "description": "Plugin that depends on other plugins",
  "main": "index.js",
  "dependencies": ["slack-notifier"],
  "hooks": {
    "after-execute": "afterExecute"
  }
}
```

### Async Plugin Operations

`index.js`:

```javascript
export async function afterExecute(context) {
  // Async operations are supported

  // 1. Read files
  const { readFile } = require('fs/promises');
  const content = await readFile('output.txt', 'utf-8');

  // 2. Make HTTP requests
  const response = await fetch('https://api.example.com/check');
  const data = await response.json();

  // 3. Run commands
  const { exec } = require('child_process');
  await new Promise((resolve, reject) => {
    exec('npm run format', (error, stdout, stderr) => {
      if (error) reject(error);
      else resolve(stdout);
    });
  });

  return { success: true };
}
```

## Plugin Best Practices

### 1. Error Handling

```javascript
export async function beforeExecute(context) {
  try {
    // Your logic here
    return { success: true };
  } catch (error) {
    console.error('[My Plugin] Error:', error);
    return {
      success: false,
      error: error.message
    };
  }
}
```

### 2. Stop Propagation

```javascript
export async function beforeExecute(context) {
  // Check some condition
  if (!shouldProceed(context)) {
    return {
      success: false,
      stopPropagation: true  // Don't call subsequent plugins
    };
  }

  return { success: true };
}
```

### 3. Modify Context

```javascript
export async function beforeExecute(context) {
  // Add custom metadata
  context.metadata.customData = {
    timestamp: Date.now(),
    user: process.env.USER,
  };

  // Modify task
  context.task = context.task + ' (with custom processing)';

  return { success: true };
}
```

### 4. Initialization

```javascript
let pluginState = {};

export async function init() {
  // One-time initialization
  console.log('[My Plugin] Initializing...');

  // Load configuration
  const config = loadConfig();
  pluginState = { config };

  // Setup resources
  await setupDatabase();

  console.log('[My Plugin] Ready!');
}

export async function destroy() {
  // Cleanup
  console.log('[My Plugin] Destroying...');

  await cleanupDatabase();
  pluginState = {};
}
```

## Testing Plugins

Create tests for your plugin:

```javascript
// tests/MyPlugin.test.js
import { describe, it, expect, beforeEach } from 'vitest';
import { PluginManager } from '../../src/plugins/PluginManager';

describe('MyPlugin', () => {
  let manager;

  beforeEach(() => {
    manager = new PluginManager();
  });

  it('should load successfully', async () => {
    const result = await manager.loadPlugin('./plugins/my-plugin');

    expect(result.success).toBe(true);
  });

  it('should register hooks', async () => {
    await manager.loadPlugin('./plugins/my-plugin');

    const plugins = manager.getPlugins();
    expect(plugins).toHaveLength(1);
  });

  it('should execute hook', async () => {
    await manager.loadPlugin('./plugins/my-plugin');

    const context = {
      sessionId: 'test-123',
      task: 'Test task',
      phase: 'test',
      config: {},
      metadata: {},
    };

    const results = await manager.executeHook('beforeExecute', context);

    expect(results).toHaveLength(1);
    expect(results[0].success).toBe(true);
  });
});
```

## See Also

- [Plugin System](../src/plugins/PluginManager.ts)
- [CLI Commands - Plugins](../USER_GUIDE.md#plugin-commands)
- [Plugin Hooks](../USER_GUIDE.md#available-hooks)
