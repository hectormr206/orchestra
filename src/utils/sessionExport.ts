/**
 * Session Export - Exporta sesiones a Markdown/JSON
 */

import { writeFile, mkdir } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';

export interface SessionData {
  id: string;
  task: string;
  startTime: string;
  endTime?: string;
  status: 'running' | 'completed' | 'failed' | 'cancelled';
  plan?: string;
  files: FileData[];
  iterations: IterationData[];
  metrics?: SessionMetrics;
  config?: Record<string, unknown>;
}

export interface FileData {
  path: string;
  description: string;
  status: 'pending' | 'created' | 'failed';
  content?: string;
  error?: string;
}

export interface IterationData {
  number: number;
  agent: string;
  adapter: string;
  startTime: string;
  endTime: string;
  success: boolean;
  output?: string;
  error?: string;
}

export interface SessionMetrics {
  totalDuration: number;
  architectDuration: number;
  executorDuration: number;
  auditorDuration: number;
  filesCreated: number;
  filesFailed: number;
  iterations: number;
  fallbacks: number;
}

/**
 * Exporta sesi√≥n a formato Markdown
 */
export function exportToMarkdown(session: SessionData): string {
  const lines: string[] = [];

  // Header
  lines.push('# Orchestra Session Report');
  lines.push('');
  lines.push('## Session Info');
  lines.push('');
  lines.push('| Property | Value |');
  lines.push('|----------|-------|');
  lines.push('| ID | ' + session.id + ' |');
  lines.push('| Status | ' + getStatusEmoji(session.status) + ' ' + session.status + ' |');
  lines.push('| Start | ' + session.startTime + ' |');
  if (session.endTime) {
    lines.push('| End | ' + session.endTime + ' |');
  }
  lines.push('');

  // Task
  lines.push('## Task');
  lines.push('');
  lines.push('```');
  lines.push(session.task);
  lines.push('```');
  lines.push('');

  // Plan
  if (session.plan) {
    lines.push('## Plan');
    lines.push('');
    lines.push(session.plan);
    lines.push('');
  }

  // Files
  if (session.files.length > 0) {
    lines.push('## Generated Files');
    lines.push('');
    for (const file of session.files) {
      const statusIcon = file.status === 'created' ? '‚úÖ' : file.status === 'failed' ? '‚ùå' : '‚è≥';
      lines.push('### ' + statusIcon + ' ' + file.path);
      lines.push('');
      lines.push('**Description:** ' + file.description);
      lines.push('');
      if (file.content) {
        const ext = file.path.split('.').pop() || '';
        lines.push('```' + ext);
        lines.push(file.content);
        lines.push('```');
        lines.push('');
      }
      if (file.error) {
        lines.push('**Error:** ' + file.error);
        lines.push('');
      }
    }
  }

  // Iterations
  if (session.iterations.length > 0) {
    lines.push('## Execution Log');
    lines.push('');
    lines.push('| # | Agent | Adapter | Duration | Status |');
    lines.push('|---|-------|---------|----------|--------|');
    for (const iter of session.iterations) {
      const duration = calculateDuration(iter.startTime, iter.endTime);
      const status = iter.success ? '‚úÖ' : '‚ùå';
      lines.push('| ' + iter.number + ' | ' + iter.agent + ' | ' + iter.adapter + ' | ' + duration + ' | ' + status + ' |');
    }
    lines.push('');
  }

  // Metrics
  if (session.metrics) {
    lines.push('## Metrics');
    lines.push('');
    lines.push('| Metric | Value |');
    lines.push('|--------|-------|');
    lines.push('| Total Duration | ' + formatDuration(session.metrics.totalDuration) + ' |');
    lines.push('| Architect Time | ' + formatDuration(session.metrics.architectDuration) + ' |');
    lines.push('| Executor Time | ' + formatDuration(session.metrics.executorDuration) + ' |');
    lines.push('| Auditor Time | ' + formatDuration(session.metrics.auditorDuration) + ' |');
    lines.push('| Files Created | ' + session.metrics.filesCreated + ' |');
    lines.push('| Files Failed | ' + session.metrics.filesFailed + ' |');
    lines.push('| Iterations | ' + session.metrics.iterations + ' |');
    lines.push('| Fallbacks | ' + session.metrics.fallbacks + ' |');
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push('*Generated by Orchestra Meta-Orchestrator*');

  return lines.join('\n');
}

/**
 * Exporta sesi√≥n a formato JSON
 */
export function exportToJSON(session: SessionData, pretty: boolean = true): string {
  return pretty ? JSON.stringify(session, null, 2) : JSON.stringify(session);
}

/**
 * Guarda sesi√≥n en archivo
 */
export async function saveSession(
  session: SessionData,
  format: 'markdown' | 'json' | 'both' = 'both',
  outputDir: string = '.orchestra/sessions'
): Promise<string[]> {
  const savedFiles: string[] = [];

  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }

  const baseFileName = 'session-' + session.id + '-' + formatDate(session.startTime);

  if (format === 'markdown' || format === 'both') {
    const mdPath = path.join(outputDir, baseFileName + '.md');
    await writeFile(mdPath, exportToMarkdown(session), 'utf-8');
    savedFiles.push(mdPath);
  }

  if (format === 'json' || format === 'both') {
    const jsonPath = path.join(outputDir, baseFileName + '.json');
    await writeFile(jsonPath, exportToJSON(session), 'utf-8');
    savedFiles.push(jsonPath);
  }

  return savedFiles;
}

// Helper functions
function getStatusEmoji(status: string): string {
  switch (status) {
    case 'completed': return '‚úÖ';
    case 'failed': return '‚ùå';
    case 'running': return 'üîÑ';
    case 'cancelled': return '‚ö†Ô∏è';
    default: return '‚ùì';
  }
}

function calculateDuration(start: string, end: string): string {
  const startMs = new Date(start).getTime();
  const endMs = new Date(end).getTime();
  return formatDuration(endMs - startMs);
}

function formatDuration(ms: number): string {
  if (ms < 1000) return ms + 'ms';
  if (ms < 60000) return (ms / 1000).toFixed(1) + 's';
  const minutes = Math.floor(ms / 60000);
  const seconds = Math.floor((ms % 60000) / 1000);
  return minutes + 'm ' + seconds + 's';
}

function formatDate(isoString: string): string {
  const date = new Date(isoString);
  return date.toISOString().split('T')[0];
}
